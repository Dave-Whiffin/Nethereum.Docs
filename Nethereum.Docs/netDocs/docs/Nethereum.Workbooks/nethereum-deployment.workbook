---
packages:
- id: Nethereum.Web3
  version: 2.0.1
uti: com.xamarin.workbook
id: 9ec7504c-70ee-4bb3-ac04-159d08f71e4a
title: nethereum-deployment
platforms:
- Console
---

## Create and deploy a smart contract to Ethereum using Nethereum (Linux/Mac OS)

## Prerequisites:

Download the test chain from https://github.com/Nethereum/Nethereum.Workbooks/tree/master/testchain/clique.

Start the chain using startgeth.bat (Windows) or startgeth.sh (Mac/Linux). The chain is setup with the Proof of Authority consensus and will start the mining process inmediatly.

The first step to be able to interact with any contract is to deploy it to the Ethereum chain.

## Nuget Packages

Please add the Nethereum.Web3 nuget package.

```csharp
#r "Nethereum.Web3"
```

## The sample

First of we will add the ‘using’ statement to Nethereum.Web3.

All other namespaces will be included directly in the sample.

```csharp
using Nethereum.Web3;
```

### **The test contract**

Here is a very simple example of a solidity contract:

** contract test { \
uint \_multiplier; **

**                           function test(uint multiplier) { \
\_multiplier = multiplier; \
} \
function multiply(uint a) returns(uint d) { \
return a \* \_multiplier; \
} \
}**

The contract named "test" has a constructor and a "multiply" function. It's also worth noting that the contract has been named after the 'contract' (class).

The ‘multiply’ function  returns the result of the multiplication of a parameter "a" by the value of the "multiplier" provided to the constructor at deployment time.

### **Contract compilation, the Bytecode and the ABI**

Before a contract can be deployed it needs to be compiled. Let's quickly see how to do this with Visual Studio Code.

#### **Visual Studio Code**

1\. Open Visual Studio Code

2\. Copy the contract test into a new file and save it as "test.sol", you will need to have opened a folder as your workspace.

3\. If you don't have the Solidity extension press **F1 or Shift+Command+P** on a mac and type "ext", then search for "solidity" and install it.

4\. Now that the Solidity extension is installed you can press F1 again type "compile" and select the option to "Compile current contract"

5\. Your abi and bytecode files can be found now in a folder called 'bin', it sits next to your Solidity file.

Here’s what **test.sol** should look like once compiled:

```csharp
"abi": "[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"multiply\",\"outputs\":[{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"multiplier\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"}]",
    "bytecode": "6060604052341561000f57600080fd5b6040516020806100d4833981016040528080519150505b60008190555b505b60988061003c6000396000f300606060405263ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663c6888fa18114603c575b600080fd5b3415604657600080fd5b604f6004356061565b60405190815260200160405180910390f35b60005481025b9190505600a165627a7a72305820f8269a6aab347f8971bfd3b9d3789464a0d50630f3388b82a84e5eedcb7f27340029"
```

Now make the compilable contract usable:

* Add “@” at the start of the abi and name it as a variable.

* Add “0X” at the start of the bytecode and name it as a variable.

```csharp
var abi = @"[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"multiply\",\"outputs\":[{\"name\":\"d\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"multiplier\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"}]";
var contractByteCode = "0x6060604052341561000f57600080fd5b6040516020806100d4833981016040528080519150505b60008190555b505b60988061003c6000396000f300606060405263ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663c6888fa18114603c575b600080fd5b3415604657600080fd5b604f6004356061565b60405190815260200160405180910390f35b60005481025b9190505600a165627a7a72305820f8269a6aab347f8971bfd3b9d3789464a0d50630f3388b82a84e5eedcb7f27340029";
```

### Deployment

#### Unlocking your account

By default, all Ethereum accounts are locked, so we’ll need to unlock our account.

Fortunately, Nethereum makes it easy with the  “web3.Personal.UnlockAccount” method.

**In C#**

```csharp
var unlockAccountResult =
        await web3.Personal.UnlockAccount.SendRequestAsync(senderAddress, password, 120);
//  Note - If using Geth 1.5.9-, duration of seconds requires a HexBigInteger.

var unlockAccountResult =
        await web3.Personal.UnlockAccount.SendRequestAsync(senderAddress, password, new HexBigInteger(120));
```

### The deployment transaction

After unlocking your account you are ready to create the transaction to deploy it.To create a deployment transaction you will use web3.Eth.DeployContract, using the abi (as we are having a constructor), the byte code, and any parameters to the constructor

````csharp

```csharp
   var transactionHash =
        await web3.Eth.DeployContract.SendRequestAsync(abi, byteCode, senderAddress, multiplier);
```

Deploying a transaction will return a transactionHash which will be using later on to retrieve the transaction receipt.

### Start mining

The transaction that has deployed the contract needs to be verified by the network, if we are running a private chain with a single node we will need to mine the transaction.

```csharp
 var mineResult = await web3.Miner.Start.SendRequestAsync(6);
```

### The transaction receipt
Once we have started mining (or we know that are miners in the network) we can can attempt to retrieve the transaction receipt, we will need this as it contains our contract address.

The transaction might have not be mined yet, so when attempting to get the receipt it might return a null value, in this scenario we will continue trying until we get a not null result.

```csharp
   var receipt = await web3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(transactionHash);

    while (receipt == null)
    {
        Thread.Sleep(5000);
        receipt = await web3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(transactionHash);
    }
```

### Stop mining

```csharp
    var mineResult = await web3.Miner.Stop.SendRequestAsync();
```

### Calling the contract function and return a value
Once we have the receipt, we can retrieve the contract address of our newly deployed contract. Using the contract address and the abi we can create an instance of the Contract object.

Using the contract we can get a Function object using the name of function.

Now with the function we will be able to do a Call to our multiply function by passing a parameter to do the multiplication.

Note: Calls are not the same as transactions so are not submitted to the network for consensus. Calls are a simple way to retrieve data or do an operation from a contract as our multiplication.

```csharp
    var contractAddress = receipt.ContractAddress;

    var contract = web3.Eth.GetContract(abi, contractAddress);

    var multiplyFunction = contract.GetFunction("multiply");

    var result = await multiplyFunction.CallAsync<int>(7);

    Assert.Equal(49, result);
```

### The final code

All the source code can be found under deployment in the [Tutorials solution](https://github.com/Nethereum/Nethereum/tree/master/src/Nethereum.Tutorials)

```csharp
    var senderAddress = "0x12890d2cce102216644c59daE5baed380d84830c";
    var password = "password";
    var abi = @"[{""constant"":false,""inputs"":[{""name"":""val"",""type"":""int256""}],""name"":""multiply"",""outputs"":[{""name"":""d"",""type"":""int256""}],""type"":""function""},{""inputs"":[{""name"":""multiplier"",""type"":""int256""}],""type"":""constructor""}]";
    var byteCode =
        "0x60606040526040516020806052833950608060405251600081905550602b8060276000396000f3606060405260e060020a60003504631df4f1448114601a575b005b600054600435026060908152602090f3";

    var multiplier = 7;

    var web3 = new Web3.Web3();
    var unlockAccountResult =
        await web3.Personal.UnlockAccount.SendRequestAsync(senderAddress, password, 120);
    Assert.True(unlockAccountResult);

    var transactionHash =
        await web3.Eth.DeployContract.SendRequestAsync(abi, byteCode, senderAddress, multiplier);

    var mineResult = await web3.Miner.Start.SendRequestAsync(6);

    Assert.True(mineResult);

    var receipt = await web3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(transactionHash);

    while (receipt == null)
    {
        Thread.Sleep(5000);
        receipt = await web3.Eth.Transactions.GetTransactionReceipt.SendRequestAsync(transactionHash);
    }

    mineResult = await web3.Miner.Stop.SendRequestAsync();
    Assert.True(mineResult);

    var contractAddress = receipt.ContractAddress;

    var contract = web3.Eth.GetContract(abi, contractAddress);

    var multiplyFunction = contract.GetFunction("multiply");

    var result = await multiplyFunction.CallAsync<int>(7);

    Assert.Equal(49, result);

```
````